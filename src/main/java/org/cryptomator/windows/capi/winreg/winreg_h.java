// Generated by jextract

package org.cryptomator.windows.capi.winreg;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class winreg_h {

    winreg_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("Advapi32"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int RRF_RT_REG_SZ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RRF_RT_REG_SZ 2
     * }
     */
    public static int RRF_RT_REG_SZ() {
        return RRF_RT_REG_SZ;
    }
    private static final int RRF_RT_REG_EXPAND_SZ = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RRF_RT_REG_EXPAND_SZ 4
     * }
     */
    public static int RRF_RT_REG_EXPAND_SZ() {
        return RRF_RT_REG_EXPAND_SZ;
    }
    private static final int RRF_RT_REG_BINARY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RRF_RT_REG_BINARY 8
     * }
     */
    public static int RRF_RT_REG_BINARY() {
        return RRF_RT_REG_BINARY;
    }
    private static final int RRF_RT_REG_DWORD = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RRF_RT_REG_DWORD 16
     * }
     */
    public static int RRF_RT_REG_DWORD() {
        return RRF_RT_REG_DWORD;
    }
    private static final int RRF_RT_REG_MULTI_SZ = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RRF_RT_REG_MULTI_SZ 32
     * }
     */
    public static int RRF_RT_REG_MULTI_SZ() {
        return RRF_RT_REG_MULTI_SZ;
    }
    private static final int RRF_RT_REG_QWORD = (int)64L;
    /**
     * {@snippet lang=c :
     * #define RRF_RT_REG_QWORD 64
     * }
     */
    public static int RRF_RT_REG_QWORD() {
        return RRF_RT_REG_QWORD;
    }
    private static final int RRF_RT_ANY = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define RRF_RT_ANY 65535
     * }
     */
    public static int RRF_RT_ANY() {
        return RRF_RT_ANY;
    }
    private static final int RRF_NOEXPAND = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define RRF_NOEXPAND 268435456
     * }
     */
    public static int RRF_NOEXPAND() {
        return RRF_NOEXPAND;
    }

    private static class RegCloseKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegCloseKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegCloseKey$descriptor() {
        return RegCloseKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegCloseKey$handle() {
        return RegCloseKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MemorySegment RegCloseKey$address() {
        return RegCloseKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static int RegCloseKey(MemorySegment hKey) {
        var mh$ = RegCloseKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCloseKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_LONG,
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegCreateKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegCreateKeyTransactedW$descriptor() {
        return RegCreateKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegCreateKeyTransactedW$handle() {
        return RegCreateKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegCreateKeyTransactedW$address() {
        return RegCreateKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegCreateKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegCreateKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyTransactedW", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_LONG,
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegDeleteKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyTransactedW$descriptor() {
        return RegDeleteKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MethodHandle RegDeleteKeyTransactedW$handle() {
        return RegDeleteKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MemorySegment RegDeleteKeyTransactedW$address() {
        return RegDeleteKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static int RegDeleteKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved, MemorySegment hTransaction, MemorySegment pExtendedParameter) {
        var mh$ = RegDeleteKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyTransactedW", hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_LONG,
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegOpenKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegOpenKeyTransactedW$descriptor() {
        return RegOpenKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegOpenKeyTransactedW$handle() {
        return RegOpenKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegOpenKeyTransactedW$address() {
        return RegOpenKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegOpenKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegOpenKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyTransactedW", hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegDeleteKeyValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyValueW$descriptor() {
        return RegDeleteKeyValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteKeyValueW$handle() {
        return RegDeleteKeyValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteKeyValueW$address() {
        return RegDeleteKeyValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static int RegDeleteKeyValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteKeyValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyValueW", hKey, lpSubKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeyValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_LONG
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegSetKeyValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetKeyValueW$descriptor() {
        return RegSetKeyValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetKeyValueW$handle() {
        return RegSetKeyValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetKeyValueW$address() {
        return RegSetKeyValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static int RegSetKeyValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetKeyValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeyValueW", hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteTreeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegDeleteTreeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteTreeW$descriptor() {
        return RegDeleteTreeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteTreeW$handle() {
        return RegDeleteTreeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteTreeW$address() {
        return RegDeleteTreeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegDeleteTreeW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteTreeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteTreeW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_LONG,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER,
            winreg_h.C_POINTER
        );

        public static final MemorySegment ADDR = winreg_h.findOrThrow("RegGetValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static FunctionDescriptor RegGetValueW$descriptor() {
        return RegGetValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MethodHandle RegGetValueW$handle() {
        return RegGetValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MemorySegment RegGetValueW$address() {
        return RegGetValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static int RegGetValueW(MemorySegment hkey, MemorySegment lpSubKey, MemorySegment lpValue, int dwFlags, MemorySegment pdwType, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = RegGetValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetValueW", hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int KEY_READ = (int)131097L;
    /**
     * {@snippet lang=c :
     * #define KEY_READ 131097
     * }
     */
    public static int KEY_READ() {
        return KEY_READ;
    }
    private static final int KEY_WRITE = (int)131078L;
    /**
     * {@snippet lang=c :
     * #define KEY_WRITE 131078
     * }
     */
    public static int KEY_WRITE() {
        return KEY_WRITE;
    }
    private static final int REG_OPTION_NON_VOLATILE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define REG_OPTION_NON_VOLATILE 0
     * }
     */
    public static int REG_OPTION_NON_VOLATILE() {
        return REG_OPTION_NON_VOLATILE;
    }
    private static final int REG_OPTION_VOLATILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define REG_OPTION_VOLATILE 1
     * }
     */
    public static int REG_OPTION_VOLATILE() {
        return REG_OPTION_VOLATILE;
    }
    private static final int REG_SZ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define REG_SZ 1
     * }
     */
    public static int REG_SZ() {
        return REG_SZ;
    }
    private static final int REG_EXPAND_SZ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define REG_EXPAND_SZ 2
     * }
     */
    public static int REG_EXPAND_SZ() {
        return REG_EXPAND_SZ;
    }
    private static final int REG_BINARY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define REG_BINARY 3
     * }
     */
    public static int REG_BINARY() {
        return REG_BINARY;
    }
    private static final int REG_DWORD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define REG_DWORD 4
     * }
     */
    public static int REG_DWORD() {
        return REG_DWORD;
    }
    private static final int REG_MULTI_SZ = (int)7L;
    /**
     * {@snippet lang=c :
     * #define REG_MULTI_SZ 7
     * }
     */
    public static int REG_MULTI_SZ() {
        return REG_MULTI_SZ;
    }
    private static final int REG_QWORD = (int)11L;
    /**
     * {@snippet lang=c :
     * #define REG_QWORD 11
     * }
     */
    public static int REG_QWORD() {
        return REG_QWORD;
    }
    private static final MemorySegment HKEY_CLASSES_ROOT = MemorySegment.ofAddress(-2147483648L);
    /**
     * {@snippet lang=c :
     * #define HKEY_CLASSES_ROOT (void*) -2147483648
     * }
     */
    public static MemorySegment HKEY_CLASSES_ROOT() {
        return HKEY_CLASSES_ROOT;
    }
    private static final MemorySegment HKEY_CURRENT_USER = MemorySegment.ofAddress(-2147483647L);
    /**
     * {@snippet lang=c :
     * #define HKEY_CURRENT_USER (void*) -2147483647
     * }
     */
    public static MemorySegment HKEY_CURRENT_USER() {
        return HKEY_CURRENT_USER;
    }
    private static final MemorySegment HKEY_LOCAL_MACHINE = MemorySegment.ofAddress(-2147483646L);
    /**
     * {@snippet lang=c :
     * #define HKEY_LOCAL_MACHINE (void*) -2147483646
     * }
     */
    public static MemorySegment HKEY_LOCAL_MACHINE() {
        return HKEY_LOCAL_MACHINE;
    }
    private static final MemorySegment HKEY_USERS = MemorySegment.ofAddress(-2147483645L);
    /**
     * {@snippet lang=c :
     * #define HKEY_USERS (void*) -2147483645
     * }
     */
    public static MemorySegment HKEY_USERS() {
        return HKEY_USERS;
    }
}

